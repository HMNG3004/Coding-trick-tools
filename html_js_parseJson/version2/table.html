<!DOCTYPE html>
<html>

<head>
    <title>Trade History Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #aaa;
            padding: 6px;
            text-align: left;
        }

        th {
            background-color: #333;
            color: white;
        }

        textarea {
            width: 100%;
            font-family: monospace;
            margin-top: 10px;
        }

        h3 {
            margin-top: 40px;
        }
    </style>
</head>

<body>

    <h2>üìÑ Load Trade History</h2>

    <input type="file" id="fileInput" accept=".txt" multiple />
    <p>ho·∫∑c paste log t·ª´ TradingView:</p>
    <textarea id="logInput" rows="6" placeholder="Paste log ·ªü ƒë√¢y, v√≠ d·ª•: [,{" Entry date":"..."}]"></textarea>
    <br><button onclick="parseRawLogs()">Parse Logs</button>

    <p id="status">Ch∆∞a c√≥ d·ªØ li·ªáu.</p>
    <div id="tableContainer"></div>

    <script>
        // Handle file input
        document.getElementById("fileInput").addEventListener("change", function (event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            document.getElementById("status").textContent = `ƒêang ƒë·ªçc ${files.length} file...`;

            const allTrades = [];
            let filesProcessed = 0;

            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const content = e.target.result;
                        const matches = content.match(/\[[\s\S]*?\]/g); // T√¨m t·∫•t c·∫£ c√°c ƒëo·∫°n JSON m·∫£ng

                        if (matches && matches.length > 0) {
                            for (let block of matches) {
                                try {
                                    block = block.replace(/^\[\s*,/, "[");
                                    block = block.replace(/,\s*\]$/, "]");

                                    const parsed = JSON.parse(block);
                                    if (Array.isArray(parsed)) {
                                        allTrades.push(...parsed);
                                    }
                                } catch (err) {
                                    console.warn(`L·ªói khi parse ƒëo·∫°n trong file ${files[i].name}:`, err.message);
                                }
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ƒëo·∫°n JSON n√†o trong file ${files[i].name}`);
                        }

                    } catch (err) {
                        console.error(`‚ùå L·ªói khi x·ª≠ l√Ω file ${files[i].name}:`, err);
                    }

                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        if (allTrades.length === 0) {
                            document.getElementById("status").textContent = `‚ùå Kh√¥ng load ƒë∆∞·ª£c trade n√†o t·ª´ ${files.length} file.`;
                        } else {
                            document.getElementById("status").textContent = `‚úÖ Loaded ${allTrades.length} trades t·ª´ ${files.length} file(s).`;
                            renderTable(allTrades);
                        }
                    }
                };

                reader.readAsText(files[i]);
            }
        });

        // Handle pasted logs
        function parseRawLogs() {
            const raw = document.getElementById("logInput").value;
            if (!raw || raw.trim() === "") return;

            try {
                // T√°ch t·ª´ng d√≤ng JSON (nhi·ªÅu ƒëo·∫°n [ {...}... ])
                const matches = raw.match(/\[[\s\S]*?\]/g); // match t·∫•t c·∫£ ƒëo·∫°n b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c b·∫±ng []

                if (!matches || matches.length === 0) {
                    document.getElementById("status").textContent = "‚ùå Kh√¥ng t√¨m th·∫•y ƒëo·∫°n JSON n√†o.";
                    return;
                }

                const allTrades = [];

                for (let block of matches) {
                    try {
                        // Xo√° d·∫•u ',' th·ª´a sau d·∫•u [
                        block = block.replace(/^\[\s*,/, "[");
                        block = block.replace(/,\s*\]$/, "]");

                        const parsed = JSON.parse(block);
                        if (Array.isArray(parsed)) {
                            allTrades.push(...parsed);
                        } else {
                            console.warn("Kh√¥ng ph·∫£i array:", block);
                        }
                    } catch (err) {
                        console.warn("L·ªói parse ƒëo·∫°n:", err.message, "\nƒêo·∫°n:", block);
                    }
                }

                if (allTrades.length === 0) {
                    document.getElementById("status").textContent = "‚ùå Kh√¥ng parse ƒë∆∞·ª£c trade n√†o.";
                    return;
                }

                document.getElementById("status").textContent = `‚úÖ Parsed ${allTrades.length} trades t·ª´ ${matches.length} ƒëo·∫°n.`;
                renderTable(allTrades);

            } catch (e) {
                document.getElementById("status").textContent = `‚ùå L·ªói khi x·ª≠ l√Ω log: ${e.message}`;
                console.error(e);
            }
        }

        // Table rendering
        function renderTable(trades) {
            if (!Array.isArray(trades) || trades.length === 0) {
                document.getElementById("tableContainer").innerHTML = "<p>Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá.</p>";
                return;
            }

            const groupByKey = (getKeyFn) => {
                const groups = {};
                const groupTimestamps = {};

                for (const trade of trades) {
                    const timestamp = parseInt(trade["Entry date"]);
                    if (!isNaN(timestamp)) {
                        const dateObj = new Date(timestamp);
                        const key = getKeyFn(dateObj);

                        if (!groups[key]) {
                            groups[key] = [];
                            groupTimestamps[key] = timestamp;
                        }

                        groups[key].push(trade);

                        // L∆∞u timestamp nh·ªè nh·∫•t l√†m m·ªëc sort
                        if (timestamp < groupTimestamps[key]) {
                            groupTimestamps[key] = timestamp;
                        }
                    }
                }

                return { groups, groupTimestamps };
            };

            const renderGroupedTable = (title, groupData) => {
                const { groups, groupTimestamps } = groupData;
                const sortedKeys = Object.keys(groups).sort((a, b) => groupTimestamps[a] - groupTimestamps[b]);

                let html = `<h2>${title}</h2>`;
                let totalRR = 0;

                for (const key of sortedKeys) {
                    const group = groups[key];
                    html += `<h3>üìÖ ${key}</h3>`;
                    html += "<table><tr>";
                    for (const col in group[0]) html += `<th>${col}</th>`;
                    html += "</tr>";

                    let groupRR = 0;
                    for (const trade of group) {
                        html += "<tr>";
                        for (const col in trade) {
                            let value = trade[col];
                            if (col.toLowerCase().includes("date") && !isNaN(value)) {
                                const date = new Date(parseInt(value));
                                value = date.toLocaleString();
                            }
                            html += `<td>${value}</td>`;
                        }
                        html += "</tr>";

                        const rr = parseFloat(trade["Actual RR"]);
                        const size_factor = parseFloat(trade["Size factor"]);
                        if (!isNaN(rr)) {
                            groupRR += rr * size_factor;
                            totalRR += rr * size_factor;
                        }
                    }

                    const colSpan = Object.keys(group[0]).length;
                    html += `<tr><td colspan="${colSpan}" style="font-weight:bold; text-align:right;">üìä Total Actual RR: ${groupRR.toFixed(3)}</td></tr>`;
                    html += "</table><br/>";
                }

                html += `<h3 style="color: darkblue;">üßæ T·ªïng Actual RR: ${totalRR.toFixed(3)}</h3><hr/>`;
                return html;
            };

            // C√°c nh√≥m
            const byDay = groupByKey(date => date.toISOString().split("T")[0]);

            const byWeek = groupByKey(date => {
                const temp = new Date(date.getTime());
                const day = temp.getDay() || 7;
                temp.setDate(temp.getDate() + 4 - day);
                const yearStart = new Date(temp.getFullYear(), 0, 1);
                const weekNo = Math.ceil((((temp - yearStart) / 86400000) + 1) / 7);
                return `${temp.getFullYear()}-W${String(weekNo).padStart(2, "0")}`;
            });

            const byMonth = groupByKey(date => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`);

            // Render theo th·ª© t·ª± th·ªùi gian th·ª±c
            let html = "";
            html += renderGroupedTable("üìÖ Th·ªëng k√™ theo ng√†y", byDay);
            html += renderGroupedTable("üìÜ Th·ªëng k√™ theo tu·∫ßn", byWeek);
            html += renderGroupedTable("üóìÔ∏è Th·ªëng k√™ theo th√°ng", byMonth);

            // üìä Table t·ªïng h·ª£p RR theo tu·∫ßn
            const weeklyRRTable = (() => {
                const { groups, groupTimestamps } = byWeek;
                const sortedWeeks = Object.keys(groups).sort((a, b) => groupTimestamps[a] - groupTimestamps[b]);

                let table = `<h2>üìä Th·ªëng k√™ RR theo tu·∫ßn</h2>`;
                table += `<table><tr><th>Tu·∫ßn</th><th>Total Actual RR</th></tr>`;

                let grandTotal = 0;
                for (const week of sortedWeeks) {
                    const group = groups[week];
                    let sum = 0;
                    for (const trade of group) {
                        const rr = parseFloat(trade["Actual RR"]);
                        const size_factor = parseFloat(trade["Size factor"]);
                        if (!isNaN(rr)) {
                            sum += rr * size_factor;
                        }
                    }
                    grandTotal += sum;
                    table += `<tr><td>${week}</td><td>${sum.toFixed(3)}</td></tr>`;
                }

                table += `<tr><td style="font-weight:bold;">T·ªïng c·ªông</td><td style="font-weight:bold;">${grandTotal.toFixed(3)}</td></tr>`;
                table += "</table><br/>";
                return table;
            })();

            html += weeklyRRTable;

            document.getElementById("tableContainer").innerHTML = html;
        }


    </script>

</body>

</html>