<!DOCTYPE html>
<html>

<head>
    <title>Trade History Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #aaa;
            padding: 6px;
            text-align: left;
        }

        th {
            background-color: #333;
            color: white;
        }

        textarea {
            width: 100%;
            font-family: monospace;
            margin-top: 10px;
        }

        h3 {
            margin-top: 40px;
        }
    </style>
</head>

<body>

    <h2>üìÑ Load Trade History</h2>

    <input type="file" id="fileInput" accept=".txt" multiple />
    <p>ho·∫∑c paste log t·ª´ TradingView:</p>
    <textarea id="logInput" rows="6" placeholder="Paste log ·ªü ƒë√¢y, v√≠ d·ª•: [,{" Entry date":"..."}]"></textarea>
    <br><button onclick="parseRawLogs()">Parse Logs</button>

    <p id="status">Ch∆∞a c√≥ d·ªØ li·ªáu.</p>
    <div id="tableContainer"></div>

    <script>
        // Handle file input
        document.getElementById("fileInput").addEventListener("change", function (event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            document.getElementById("status").textContent = `ƒêang ƒë·ªçc ${files.length} file...`;

            const allTrades = [];
            let filesProcessed = 0;

            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const content = e.target.result;
                        const matches = content.match(/\[[\s\S]*?\]/g); // T√¨m t·∫•t c·∫£ c√°c ƒëo·∫°n JSON m·∫£ng

                        if (matches && matches.length > 0) {
                            for (let block of matches) {
                                try {
                                    block = block.replace(/^\[\s*,/, "[");
                                    block = block.replace(/,\s*\]$/, "]");

                                    const parsed = JSON.parse(block);
                                    if (Array.isArray(parsed)) {
                                        allTrades.push(...parsed);
                                    }
                                } catch (err) {
                                    console.warn(`L·ªói khi parse ƒëo·∫°n trong file ${files[i].name}:`, err.message);
                                }
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ƒëo·∫°n JSON n√†o trong file ${files[i].name}`);
                        }

                    } catch (err) {
                        console.error(`‚ùå L·ªói khi x·ª≠ l√Ω file ${files[i].name}:`, err);
                    }

                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        if (allTrades.length === 0) {
                            document.getElementById("status").textContent = `‚ùå Kh√¥ng load ƒë∆∞·ª£c trade n√†o t·ª´ ${files.length} file.`;
                        } else {
                            document.getElementById("status").textContent = `‚úÖ Loaded ${allTrades.length} trades t·ª´ ${files.length} file(s).`;
                            renderTable(allTrades);
                        }
                    }
                };

                reader.readAsText(files[i]);
            }
        });

        // Handle pasted logs
        function parseRawLogs() {
            const raw = document.getElementById("logInput").value;
            if (!raw || raw.trim() === "") return;

            try {
                // T√°ch t·ª´ng d√≤ng JSON (nhi·ªÅu ƒëo·∫°n [ {...}... ])
                const matches = raw.match(/\[[\s\S]*?\]/g); // match t·∫•t c·∫£ ƒëo·∫°n b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c b·∫±ng []

                if (!matches || matches.length === 0) {
                    document.getElementById("status").textContent = "‚ùå Kh√¥ng t√¨m th·∫•y ƒëo·∫°n JSON n√†o.";
                    return;
                }

                const allTrades = [];

                for (let block of matches) {
                    try {
                        // Xo√° d·∫•u ',' th·ª´a sau d·∫•u [
                        block = block.replace(/^\[\s*,/, "[");
                        block = block.replace(/,\s*\]$/, "]");

                        const parsed = JSON.parse(block);
                        if (Array.isArray(parsed)) {
                            allTrades.push(...parsed);
                        } else {
                            console.warn("Kh√¥ng ph·∫£i array:", block);
                        }
                    } catch (err) {
                        console.warn("L·ªói parse ƒëo·∫°n:", err.message, "\nƒêo·∫°n:", block);
                    }
                }

                if (allTrades.length === 0) {
                    document.getElementById("status").textContent = "‚ùå Kh√¥ng parse ƒë∆∞·ª£c trade n√†o.";
                    return;
                }

                document.getElementById("status").textContent = `‚úÖ Parsed ${allTrades.length} trades t·ª´ ${matches.length} ƒëo·∫°n.`;
                renderTable(allTrades);

            } catch (e) {
                document.getElementById("status").textContent = `‚ùå L·ªói khi x·ª≠ l√Ω log: ${e.message}`;
                console.error(e);
            }
        }

        // Table rendering
        function renderTable(trades) {
            if (!Array.isArray(trades) || trades.length === 0) {
                document.getElementById("tableContainer").innerHTML = "<p>Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá.</p>";
                return;
            }

            const groups = {};
            for (const trade of trades) {
                let timestamp = parseInt(trade["Entry date"]);
                if (!isNaN(timestamp)) {
                    const dateObj = new Date(timestamp);
                    const dateKey = dateObj.toISOString().split("T")[0];
                    if (!groups[dateKey]) groups[dateKey] = [];
                    groups[dateKey].push(trade);
                }
            }

            let html = "";
            let globalTotalRR = 0;
            const sortedDates = Object.keys(groups).sort();

            for (const dateKey of sortedDates) {
                const group = groups[dateKey];
                html += `<h3>üìÖ ${dateKey}</h3>`;
                html += "<table><tr>";
                for (const key in group[0]) {
                    html += `<th>${key}</th>`;
                }
                html += "</tr>";

                let dailyTotalRR = 0;
                for (const trade of group) {
                    html += "<tr>";
                    for (const key in trade) {
                        let value = trade[key];
                        if (key.toLowerCase().includes("date") && !isNaN(value)) {
                            const date = new Date(parseInt(value));
                            value = date.toLocaleString();
                        }
                        html += `<td>${value}</td>`;
                    }
                    html += "</tr>";

                    const rr = parseFloat(trade["Actual RR"]);
                    const size_factor = parseFloat(trade["Size factor"]);
                    if (!isNaN(rr)) {
                        dailyTotalRR += rr * size_factor;
                        globalTotalRR += rr * size_factor;
                    }
                }

                const colSpan = Object.keys(group[0]).length;
                html += `<tr><td colspan="${colSpan}" style="font-weight:bold; text-align:right;">üìä Total Actual RR: ${dailyTotalRR.toFixed(3)}</td></tr>`;
                html += "</table><br/>";
            }

            html += `<h3 style="color: darkblue;">üßæ T·ªïng Actual RR to√†n b·ªô: ${globalTotalRR.toFixed(3)}</h3>`;
            document.getElementById("tableContainer").innerHTML = html;
        }
    </script>

</body>

</html>